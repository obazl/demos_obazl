
Step 1 for dune: run ocamldep
Step 2: run make to get the cclib

Step 3: compile dune__exe.ml-gen
    namespace module, e.g.
    (** @canonical Dune__exe.Types_generated *)
    module Types_generated = Dune__exe__Types_generated

Step 4: compile type_description.ml

     rename: type_description => foo_types

Step 5: compile libfoo__type_gen.ml  (namespaced type_gen.ml)
    outputs namespaced: dune__exe__Libfoo__type_gen.cmo/cmx

    generated by dune, ctypes/ctypes_rules.ml::type_gen_gen
    used to generate C code from (foo) Types functor
    rename: type_description => foo_types or foo_api_types
    rename: function_description => foo_functions
    rename: type_gen.ml => ???

content:

let () =
  print_endline "#include <foo.h>";
  Cstubs_structs.write_c Format.std_formatter
    (module Type_description.Types)

NB: this generates a c pgm
    that generates an ml module
    (that implements Ctypes.TYPE)
    that is used to parameterize the Foo Types functor
    that produces the Foo Types module

Step 6: compile type_description.ml
    outputs namespaced: dune__exe__Type_description.cmx/cmo

Step 7: link libfoo__type_gen.exe
    manifest: ctypes, ctypes.stubs, dune__exe.cmx (ns)
    dune__exe__Type_description.cmx
    dune__exe__Libfoo__type_gen.cmx (main)

Step 8: run libfoo__type_gen.exe
    output: libfoo__c_cout_generated_types.c

    this is a c tool (pgm) that generates ml code
    that implements a module of mtype Ctypes.TYPE
    specialized for foo (in this case, const FOO_VERSION).
    that ml code will be compiled and used to parameterize
    the Types functor of type_description.ml

    so the output name s/b CtypesType_FooGenerator,
    or FooTypesImpl_Generator
    which will generate FooTypesImpl
    It's a module that implements
    Ctypes.TYPE with Foo specializations?

    i.e. an implementation param for the foo Types functor

    (Not FooTypesModule, that's the result of applying the
    Types functor to this FooTypesImpl module.)


Step 9: cc compile and link libfoo__c_cout_generated_types.c
     output: libfoo__c_cout_generated_types.exe

     aka fooTypes_impl_generator.c

     rename: fooTypesImpl_Generator.exe

Step 10: run libfoo__c_cout_generated_types.exe
     output: libfoo__c_generated_types.ml

     rename output: FooTypesImpl.ml

     output is an implementation of Ctype.TYPE
     with foo specializations
     it 'include's Ctypes and opens Ctypes_static
     will be used below to parameterize functor
     Type_description.Types

    (then run ocamldep on libfoo__c_generated_types.ml)

Step 11: compile libfoo__c_generated_types.ml
     output: dune__exe__Libfoo__c_generated_types.cmo

     renaming: FooTypesImpl.ml => FooTypesImpl.cmo

Step 12: compile types_generated.ml
     output: dune__exe__Types_generated.cmo

     types_generated.ml created by dune, from 'generated_types'
     fld of 'ctypes' stanza
     rename: TypesModule_from_Functor or FooTypesImpl
     or FooTypesModule
     (the Types functor is for libfoo types, so it should
     yield a FooTypes module - foo already implies c types)
     generated by dune: ctypes/ctypes_rules.ml::write_c_types_includer_module
     contents:

include Type_description.Types (Libfoo__c_generated_types)

[s/b Foo.Types (FooTypesImpl) ]

################################################################
PHASE 2:  functions

Step 13: compile function_description.ml
     output: dune__exe__Function_description.cmo

Step 14: compile libfoo__function_gen__Function_description__Functions.ml
     output: dune__exe__Libfoo__function_gen__Function_description__Functions.cmo

     rename: FooFuncs.ml

     cmd pgm, Cstubs.write_ml or Cstubs.write_c, depending on arg
     write arg: (module Function_description.Functions)

     generated by dune, ctypes/ctypes_field.ml::function_gen_script
     compiled with -no-alias-deps, so no explicit dep
     on function_description.ml
     purpose? just to gen code from the Funtions functor
     content:

let () =
  let concurrency = Cstubs.unlocked in
  let errno = Cstubs.ignore_errno in
  let prefix = Sys.argv.(2) in
  match Sys.argv.(1) with
  | "ml" ->
    Cstubs.write_ml ~concurrency Format.std_formatter ~prefix
      ~errno
      (module Function_description.Functions)
  | "c" ->
  print_endline "#include <foo.h>";
    Cstubs.write_c ~concurrency Format.std_formatter ~prefix
      ~errno
      (module Function_description.Functions)
  | s -> failwith ("unknown functions "^s)


Step 15: compile types_generated.ml (cmx)
     output: dune__exe__Types_generated.cmx

     should be called: TypesFunctorApplication
     or just FooTypes?

Step 16: compile libfoo__c_generated_types.ml (cmx)
     output: dune__exe__Libfoo__c_generated_types.cmx

Step 17: compile function_description.ml (cmx)
     output: dune__exe__Function_description.cmx

Step 18: compile libfoo__function_gen__Function_description__Functions.ml (again)
     output: dune__exe__Libfoo__function_gen__Function_description__Functions.cmx

Step 19: link libfoo__function_gen__Function_description__Functions.exe
     manifest:
     dune__exe.cmx  (ns resolver)
     dune__exe__Libfoo__c_generated_types.cmx
     dune__exe__Type_description.cmx
     dune__exe__Types_generated.cmx
     dune__exe__Function_description.cmx (main)

Step 20: run it, with arg 'c'
     libfoo__function_gen__Function_description__Functions.exe c libfoo_stubs
     output: libfoo__c_cout_generated_functions__Function_description__Functions.c

Step 21: run it again, with arg 'ml'
     (libfoo__function_gen__Function_description__Functions.exe ml libfoo_stubs) > _build/default/libfoo__c_generated_functions__Function_description__Functions.ml

     (then run ocamldep on the ouput ml file)

Step 22: process foo.ml

    a. run ocamldep on foo.mli, which is empty, generated by dune
    b. compile foo.mli

Step 23: compile (cmo)
     libfoo__c_generated_functions__Function_description__Functions.ml
     output: dune__exe__Libfoo__c_generated_functions__Function_description__Functions.cmo

     (compare:
     libfoo__function_gen__Function_description__Functions.ml
     libfoo__c_cout_generated_functions__Function_description__Functions.c

Step 24: cc compile
     libfoo__c_cout_generated_functions__Function_description__Functions.c

Step 25: compile c.ml, output dune__exe__C.cmo

     c.ml generated by dune
     name from 'generated_entry_point' fld of 'ctypes' stanza
     content:

module Types = Types_generated
module Functions = Function_description.Functions (Libfoo__c_generated_functions__Function_description__Functions)


Step 26: compile (cmx)
     libfoo__c_generated_functions__Function_description__Functions.ml
     output: dune__exe__Libfoo__c_generated_functions__Function_description__Functions.cmx

Step 27: compile foo.ml, output: dune__exe__Foo.cmx

Step 28: compile  c.ml output: dune__exe__C.cmx

Step 29: link foo.exe
     manifest:
     dune__exe.cmx
     dune__exe__Libfoo__c_generated_types.cmx
     dune__exe__Type_description.cmx
     dune__exe__Types_generated.cmx
     dune__exe__Function_description.cmx
     dune__exe__Libfoo__c_generated_functions__Function_description__Functions.cmx
     dune__exe__C.cmx
     dune__exe__Foo.cmx (main)

     ccdeps:
     libfoo__c_cout_generated_functions__Function_description__Functions.o
     libfoo.a
